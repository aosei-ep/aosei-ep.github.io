<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>高等数学常用公式汇总</title>
    <url>/2022/04/22/AdvancedMathematics/</url>
    <content><![CDATA[<head>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
</head>

<h2 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h2><h3 id="二倍角"><a href="#二倍角" class="headerlink" title="二倍角"></a>二倍角</h3><p><code>sin2α</code> = <code>2 sinα cosα</code></p>
<p><code>cos2α</code> = <code>cos<sup>2</sup>α - sin<sup>2</sup>α</code> = <code>2cos<sup>2</sup>α - 1</code> = <code>1 - 2sin<sup>2</sup>α</code></p>
<p><code>tan2α</code> = <code><strong>$\frac&#123;2tanα&#125;&#123;1 - tan^&#123;2&#125;α&#125;$</strong></code>    【注】α ≠ <strong>$\frac{π}{2}$</strong> + kπ ; α ≠ <strong>$\frac{π}{4}$</strong> + kπ (k∈Z)</p>
<h3 id="半角"><a href="#半角" class="headerlink" title="半角"></a>半角</h3><p><code>sin$\frac&#123;α&#125;&#123;2&#125;$</code> = <code>±$\sqrt&#123;\frac&#123;1 - cosα&#125;&#123;2&#125;&#125;$</code></p>
<p><code>cos$\frac&#123;α&#125;&#123;2&#125;$</code> = <code>±$\sqrt&#123;\frac&#123;1 + cosα&#125;&#123;2&#125;&#125;$</code></p>
<p><code>tan$\frac&#123;α&#125;&#123;2&#125;$</code> = <code>±$\sqrt&#123;\frac&#123;1 - cosα&#125;&#123;1 + cosα&#125;&#125;$</code></p>
<p><code>sin$\frac&#123;θ&#125;&#123;2&#125;$</code> = <code>$\frac&#123;1 - cosθ&#125;&#123;sinθ&#125;$</code> = <code>$\frac&#123;sinθ&#125;&#123;1 + cosθ&#125;$</code></p>
<p><br></p>
<h2 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h2><h3 id="常用等价无穷小代换-lim-limits-x-to-0"><a href="#常用等价无穷小代换-lim-limits-x-to-0" class="headerlink" title="常用等价无穷小代换($\lim\limits_{x \to 0}$)"></a>常用等价无穷小代换($\lim\limits_{x \to 0}$)</h3><p><code>$x$</code> ~ <code>$sinx$</code> ~ <code>$tanx$</code> ~ <code>$arcsinx$</code> ~ <code>$arctanx$</code> ~ <code>$e^&#123;x&#125; - 1$</code> ~ <code>$ln(1 + x)$</code></p>
<p><code>$a^x - 1$</code> ~ <code>$xlna$</code></p>
<p><code>$log_a(1 + x)$</code> ~ <code>$\frac&#123;x&#125;&#123;\ln a&#125;$</code></p>
<p><code>$1 - cosx$</code> ~ <code>$secx - 1$</code> ~ <code>$\frac&#123;1&#125;&#123;2&#125;x^2$</code></p>
<p><code>$(1 + Bx)^a - 1$</code> ~ <code>$aBx$</code>    <strong>【拓展】若</strong>$α(x) \to 0$<strong>，</strong> $α(x)β(x) \to 0$<strong>，则</strong><code>$[1 + α(x)]^&#123;β(x)&#125; - 1$</code> ~ <code>$α(x)β(x)$</code></p>
<p><code>$x - sinx$</code> ~ <code>$arcsinx - x$</code> ~ <code>$\frac&#123;1&#125;&#123;6&#125;x^3$</code></p>
<p><code>$x - ln(1 + x)$</code> ~ <code>$\frac&#123;1&#125;&#123;2&#125;x^2$</code></p>
<p><code>tan$x$ - $x$</code> ~ <code>$x$ - arctan$x$</code> ~ <code>$\frac&#123;1&#125;&#123;3&#125;x^3$</code></p>
<h3 id="1-infty-型极限"><a href="#1-infty-型极限" class="headerlink" title="$1^\infty$型极限"></a>$1^\infty$型极限</h3><p><strong>若</strong> $\lim\alpha(x) = 0$<strong>，</strong>$\lim\beta(x) = \infty$，<strong>且</strong> $\lim\alpha(x)\beta(x) = A$<strong>，则</strong> <code>$\lim(1 + \alpha(x))^&#123;\beta(x)&#125; = e^A$</code></p>
<h3 id="等价代换的条件"><a href="#等价代换的条件" class="headerlink" title="等价代换的条件"></a>等价代换的条件</h3><ul>
<li><p><strong>乘除关系任何时候都可以代换</strong></p>
</li>
<li><p><strong>加减关系在一定条件下可以换</strong></p>
<p>若 $\alpha\sim\alpha_1,\beta\sim\beta_1$</p>
<ol>
<li>且 $\lim\frac{\alpha_1}{\beta_1}=A\not=1$，则 $\alpha-\beta=\alpha_1-\beta_1$</li>
<li>且 $\lim\frac{\alpha_1}{\beta_1}=A\not=-1$，则 $\alpha+\beta=\alpha_1+\beta_1$</li>
</ol>
</li>
</ul>
<h3 id="间断点"><a href="#间断点" class="headerlink" title="间断点"></a>间断点</h3><ol>
<li><strong>第一类间断点：</strong>左右极限点均存在<ul>
<li>可去间断点：左极限 = 右极限</li>
<li>跳跃间断点：左极限 ≠ 右极限</li>
</ul>
</li>
<li><strong>第二类间断点：</strong>左右极限中至少有一个不存在<ul>
<li>无穷间断点：【例】$\lim\limits_{x \to \infty}\frac{1}{x}$</li>
<li>振动间断点：【例】$\lim\limits_{x \to \infty}\sin x$</li>
</ul>
</li>
</ol>
<p><em><u>第二类间断点不需要说明具体类型</u></em></p>
<p><br></p>
<p><br></p>
<h2 id="导数"><a href="#导数" class="headerlink" title="导数"></a>导数</h2><h3 id="基本初等函数的导数公式"><a href="#基本初等函数的导数公式" class="headerlink" title="基本初等函数的导数公式"></a>基本初等函数的导数公式</h3><ol>
<li>$(a^x)^{′} = a^x\ln a$</li>
<li>$(\log _ax)^{′} = \frac{1}{x\ln a}$</li>
<li>$(\tan x)^{′} = \sec^2x$</li>
<li>$(\cot x)^{′} = -\csc^2x$</li>
<li>$(\sec x)^{′} = \sec x\tan x$</li>
<li>$(\csc x)^{′} = -\csc x\cot x$</li>
<li>$(\arcsin x)^{′} = \frac{1}{\sqrt{1 - x^2}}$</li>
<li>$(\arccos x)^{′} = -\frac{1}{\sqrt{1 - x^2}}$</li>
<li>$(\arctan x)^{′} = \frac{1}{1 + x^2}$</li>
<li>$(\text{arccot} x)^{′} = -\frac{1}{1 + x^2}$</li>
</ol>
<h3 id="常用高阶导"><a href="#常用高阶导" class="headerlink" title="常用高阶导"></a>常用高阶导</h3><ol>
<li>$(\sin x)^{(n)} = \sin(x + n\cdot\frac{\pi}{2})$</li>
<li>$(\cos x)^{(n)} = \cos(x + n\cdot\frac{\pi}{2})$</li>
<li>$(u \pm v)^{(n)} = u^{(n)} \pm v^{(n)}$</li>
<li>$(uv)^{(n)} = \sum\limits_{i = 1}^n C{^k_n}u^{(k)}v^{(n-k)}$</li>
</ol>
<h3 id="常用泰勒公式"><a href="#常用泰勒公式" class="headerlink" title="常用泰勒公式"></a>常用泰勒公式</h3><ol>
<li>$e^x = 1 + x + \frac{x^2}{2!} + \cdots + \frac{x^n}{n!} + o(x^n)$</li>
<li>$\sin x = x - \frac{x^3}{3!} + \cdots + (-1)^{n - 1}\frac{x^{2n - 1}}{(2n - 1)!} + o(x^{2n})$</li>
<li>$\cos x = 1 - \frac{x^2}{2!} + \cdots + (-1)^n \frac{x^{2n}}{(2n)!} + o(x^{2n})$</li>
<li>$\ln (1 + x) = x - \frac{x^2}{2} + \cdots + (-1)^{n - 1}\frac{x^n}{n} + o(x^n)$</li>
<li>$(1 + x)^\alpha = 1 + \alpha x + \frac{\alpha(\alpha - 1)}{2!}x^2 + \cdots + \frac{\alpha(\alpha - 1)\cdots(\alpha- n + 1)}{n!}x^n + o(x^n)$</li>
</ol>
<p><strong>存在</strong> $\alpha(x) \text~ \beta(x) \Rightarrow \alpha(x) = \beta(x) + o(\beta(x))$</p>
<p><strong>【例】</strong> $\tan x - x \text~ \frac{1}{3}x^3 \Rightarrow \tan x = x + \frac{1}{3}x^3 + o(x^3)$</p>
<h3 id="曲线的凹凸性"><a href="#曲线的凹凸性" class="headerlink" title="曲线的凹凸性"></a>曲线的凹凸性</h3><ul>
<li><strong>凹</strong> <ul>
<li><strong>定义</strong> $f(\frac{x_1 + x_2}{2}) &lt; \frac{f(x_1)+f(x_2)}{2}$</li>
<li><strong>定理</strong> 若在区间 $I$ 上 $f^{′′}&gt;0$ 则曲线 $y = f(x)$ 在 $I$ 上是<b><u>凹</u></b>的</li>
</ul>
</li>
<li><strong>凸</strong> <ul>
<li><strong>定义</strong> $f(\frac{x_1 + x_2}{2}) &gt; \frac{f(x_1)+f(x_2)}{2}$</li>
<li><strong>定理</strong> 若在区间 $I$ 上 $f^{′′}<0$ 则曲线 $y = f(x)$ 在 $I$ 上是<b><u>凸</u>&lt;/b&gt;的</li>
</ul>
</li>
<li><strong>拐点</strong>(凹凸发生改变)<ul>
<li><strong>定义</strong> $f^{′′}(x) = 0$ 且 $f^{′′′}(x) \not= 0$ 或 $f^{′′}(0)$ 两侧变号</li>
</ul>
</li>
</ul>
<h3 id="曲线的渐近线"><a href="#曲线的渐近线" class="headerlink" title="曲线的渐近线"></a>曲线的渐近线</h3><ul>
<li><p><strong>水平渐近线</strong></p>
<p>若 $\lim\limits_{x\to\infty}f(x)=A$ 则 $y = A$ 是曲线的<u>水平渐近线</u>（$x\to+\infty$ 或 $x\to-\infty$）</p>
</li>
<li><p><strong>垂直渐近线</strong></p>
<p>若 $\lim\limits_{x\to x_0}f(x)=\infty$，那么 $x = x_0$ 是曲线的<u>垂直渐近线</u></p>
</li>
<li><p><strong>斜渐近线</strong></p>
<p>若 $\lim\limits_{x\to\infty}\frac{f(x)}{x}=a$，$b = \lim\limits_{x\to\infty}(f(x)-ax)$，那么 $y=ax+b$ 是曲线的<u>斜渐近线</u></p>
</li>
</ul>
<p><br></p>
<p><br></p>
<h2 id="不定积分"><a href="#不定积分" class="headerlink" title="不定积分"></a>不定积分</h2><h3 id="常用不定积分公式"><a href="#常用不定积分公式" class="headerlink" title="常用不定积分公式"></a>常用不定积分公式</h3><ol>
<li>$\int0dx=C$</li>
<li>$\int x^a = \frac{1}{\alpha+1}x^{\alpha+1}+C$  $(α \not= -1)$</li>
<li>$\int\frac{1}{x}dx=\ln|x|+C$</li>
<li>$\int a^xdx=\frac{a^x}{\ln a}+C$  $(a&gt;0,a\not=1)$</li>
<li>$\int\frac{dx}{\sqrt{a^2-x^2}}=\arcsin\frac{x}{a}+C$</li>
<li>$\int\frac{dx}{a^2+x^2}=\frac{1}{a}\arctan\frac{x}{a}+C$</li>
<li>$\int\frac{dx}{x^2-a^2}=\frac{1}{2a}ln|\frac{x-a}{x+a}|+C$</li>
<li>$\int\frac{dx}{\sqrt{x^2+a^2}}=\ln(x+\sqrt{x^2+a^2})+C$</li>
<li>$\int\frac{dx}{\sqrt{x^2-a^2}}=\ln|x+\sqrt{x^2-a^2}|+C$</li>
<li>$\int\sec xdx=\ln|\sec x+\tan x|+C$</li>
<li>$\int\csc xdx=-\ln|\csc x+\cot x|+C$</li>
</ol>
<h3 id="常用积分法"><a href="#常用积分法" class="headerlink" title="常用积分法"></a>常用积分法</h3><ol>
<li><p><strong>凑微分法</strong></p>
</li>
<li><p><strong>换元积分法</strong></p>
<p>常用换元</p>
<ul>
<li>$\sqrt{a^2-x^2}$  可令 $x=a\sin t$ 或 $x=a\cos t$</li>
<li>$\sqrt{a^2+x^2}$  可令 $x=a\tan t$</li>
<li>$\sqrt{x^2-a^2}$  可令 $x=a\sec t$ </li>
</ul>
</li>
<li><p><strong>分部积分法</strong></p>
<p>$\int{u\text dv}=uv-\int{v\text du}$</p>
<p>$\int{uv^′\text dx}=uv-\int{vu^′\text dx}$</p>
<p>适用于两类不同函数相乘</p>
<ul>
<li>$\int P_n(x)e^{\alpha x}\text dx$    放入 $e^{\alpha x}$</li>
<li>$\int P_n(x)\sin{\alpha x}\text dx$ 放入 $\sin \alpha x$</li>
<li>$\int P_n(x)\cos{\alpha x}\text dx$ 放入 $\cos{\alpha x}$</li>
<li>$\int P_n(x)\ln x\text dx$ 放入 $P_n(x)$</li>
<li>$\int P_n(x)\arctan x\text dx$ 放入 $P_n(x)$</li>
<li>$\int P_n(x)\arcsin x\text dx$ 放入 $P_n(x)$</li>
<li>$\int e^{\alpha a}\sin \mu x\text dx$ 放入二者其一都可</li>
<li>$\int e^{\alpha x}\cos\beta x\text dx$ 放入二者其一都可</li>
</ul>
<p>【例】<script type="math/tex">\begin{array}\int\frac{\ln\sin x}{\sin^2x}\text dx \\\\= \int\ln\sin x\text d\cot x\\\\=-\cot x\ln\sin x+\int\cot^2x\text dx\\\\=-\cot x\ln\sin x+\int(\csc^2x-1)\text dx\\\\=-cot x\ln\sin x-\cot x-x+C\end{array}</script></p>
</li>
</ol>
<p><br></p>
<p><br></p>
<h2 id="做题总结"><a href="#做题总结" class="headerlink" title="做题总结"></a>做题总结</h2><h3 id="极限-1"><a href="#极限-1" class="headerlink" title="极限"></a>极限</h3><ul>
<li><p><strong>【题1】</strong> <b>若 $\lim\limits_{x\to0}\frac{x-\sin ax}{\int^{x}_0\frac{t^2}{\sqrt{b+t^4}}\mathrm{d}t}=2$，则 $a=?,b=?.$ </b></p>
<p>解：令 $f(t)=t^2,g(t)=\frac{1}{\sqrt{b+t^4}}$</p>
<p>则 $\int^{x}_0\frac{t^2}{\sqrt{b+t^4}}\mathrm{d}x=\int^{x}_0f(t)g(t)\mathrm{d}x$</p>
<p>且 $g(x)$ 在 $[0,x]$ 上单调减，$g(x)\ge0$</p>
<p>故存在 $\xi\in[0,x]$ ，有 $\int^{x}_0f(t)g(t)=g(0)\int^{\xi}_0f(x)\mathrm{d}t$</p>
<p>即 $\int^{x}_0\frac{t^2}{\sqrt{b+t^4}}\mathrm{d}t=\frac{1}{\sqrt{b}}\int^{\xi}_0t^2\mathrm{d}t=\frac{x^3}{3\sqrt{b}}$</p>
<p>由于 $\lim\limits_{x\to0}\frac{x^3}{3\sqrt{b}}=0$，则 $\lim\limits_{x\to0}(x-\sin ax)=0\Rightarrow a=1$</p>
<p>所以 $\lim\limits_{x\to0}\frac{x-\sin x}{\int^{x}_0\frac{t^2}{\sqrt{b+t^4}}\mathrm{d}t}=\sqrt{b}\lim\limits_{x\to0}\frac{1-\cos{x}}{x^2}=\frac{\sqrt{b}}{2}=2$</p>
<p>解得$\left\lbrace\begin{array}{lcl}a=1\\b=16\end{array}\right.$</p>
<blockquote>
<p>  <b><u>【注】积分第二中值定理</u></b>，设函数 $f$ 在 $[a,b]$ 上可积</p>
<ul>
<li><p>若函数 $g(x)$ 在 $[a,b]$ 上<strong>减</strong>，且 $g(x)\ge0$ 则存在 $\xi\in[a,b]$，使得</p>
<p>$\int^{b}_{a}f(x)g(x)\mathrm{d}x=g(a)\int^{\xi}_{a}f(x)\mathrm{d}x$</p>
</li>
<li><p>若函数 $g(x)$ 在 $[a,b]$ 上<strong>增</strong>，且 $g(x)\ge0$ 则存在 $\xi\in[a,b]$，使得</p>
<p>$\int^{b}_{a}f(x)g(x)\mathrm{d}x=g(b)\int^{b}_{\xi}f(x)\mathrm{d}x$</p>
</li>
</ul>
</blockquote>
</li>
</ul>
<hr>

<ul>
<li><p><strong>【题2】</strong> <b>若 $\lim\limits_{x\to0}\frac{\sin x}{e^x-a}(\cos x-b)=5$，则 $a=?, b=?.$ </b></p>
<p>解：$\lim\limits_{x\to0}\frac{\sin x}{e^x-a}(\cos x-b)=\frac{\sin0}{e^0-a}(\cos0-b)$</p>
<p>因为 $\sin 0$ 为 0 ，要让极限成立则 $e^x-a$ 也需要为 0，可得 $a = 1$</p>
<p>于是 $\lim\limits_{x\to0}\frac{\sin x}{e^x-1}(\cos x-b) = \lim\limits_{x\to0}(\cos x-b) = 1-b=5$</p>
<p>最后解得 $\left\lbrace\begin{array}{lcl}a=1\\b=-4\end{array}\right.$</p>
</li>
</ul>
<hr>

<ul>
<li><p><strong>【题3】</strong></p>
<p>$\lim\limits_{x\to1}\frac{\sin^2x}{(x-1)\ln{x}}=\lim\limits_{x\to1}\frac{\sin^2[\pi+\pi(x-1)]}{(x-1)^2}=\lim\limits_{x\to1}\frac{\sin^2[\pi(x-1)]}{(x-1)^2}=\pi^2$</p>
<p><u>运用到了函数的周期性</u></p>
</li>
</ul>
<hr>

<ul>
<li><p><strong>【题4】</strong></p>
<p>由于 $(x+1)^{10}=C^0_{10}x^{10}+C^1_{10}x^{9}+\cdots=x^{10}+10x^9+\cdots$</p>
<p>$(x-1)^{10}=C^0_{10}x^{10}-C^1_{10}x^{9}+\cdots=x^{10}-10x^9+\cdots$</p>
<p>$\lim\limits_{x\to1}\frac{x^9}{(x+1)^{10}-(x-1)^{10}}=\frac{x^9}{20x^9+\cdots}=\frac{1}{20}$</p>
</li>
</ul>
<hr>

<ul>
<li><p><strong>【题5】</strong> <b>$\lim\limits_{x\to+\infty}x^2(\arctan{\frac{1}{2x-1}}-\arctan{\frac{1}{2x+1}})$</b></p>
<p>令 $f(t)=\arctan t,f^{′}(t)=\frac{1}{1+t^2}$，由<u>拉格朗日中值定理</u>得</p>
<p>$\arctan\frac{1}{2x-1}-\arctan\frac{1}{2x+1}=f^{′}(\xi)\cdot(\frac{1}{2x-1}-\frac{1}{2x+1})=\frac{1}{1+\xi^2}\cdot\frac{2}{4x^2-1}$</p>
<p>则 $原式=\lim\limits_{x\to+\infty}\frac{1}{1+\xi^2}\cdot\frac{2x^2}{4x^2-1}=\frac{1}{2}$</p>
</li>
</ul>
<hr>

<ul>
<li><strong>【题6】</strong> <code>注: $\ln&#123;x&#125;=-\ln&#123;\frac&#123;1&#125;&#123;x&#125;&#125;$</code><ol>
<li>$\lim\limits_{x\to0^+}(\frac{1}{x})^{\tan{2x}}=e^{\lim\limits_{x\to0^+}\tan{2x}\cdot\ln{\frac{1}{x}}}=e^{-2\lim\limits_{x\to0^+}\frac{\tan{2x}}{2x}\cdot\frac{\ln{x}}{\frac{1}{x}}}=e^{-2\lim\limits_{x\to0^+}\frac{\frac{1}{x}}{-\frac{1}{x^2}}}=e^0=1$</li>
<li>$\lim\limits_{x\to0^+}(\frac{1}{x})^{\tan{2x}}=e^{\lim\limits_{x\to0^+}\sin{2x}\cdot\ln{\frac{1}{x}}}=e^{2\lim\limits_{x\to0^+}\frac{\sin{2x}}{2x}\cdot\frac{\ln{x}}{\frac{1}{x}}}=e^{2\lim\limits_{x\to0^+}\frac{\frac{1}{x}}{-\frac{1}{x^2}}}=e^0=1$</li>
</ol>
</li>
</ul>
<hr>

<ul>
<li><p><strong>【题7】</strong></p>
<ol>
<li><p>$\lim\limits_{x\to0}\frac{\tan(\tan{x})-x}{x(1-\sqrt{\cos x})}=\lim\limits_{x\to0}\frac{[\tan{(\tan{x})}-x]\cdot(1+\cos{x})}{x\cdot(1-\cos{x})}=4\lim\limits_{x\to0}(\frac{\tan{(\tan{x})}-\tan{x}}{x^3}+\frac{\tan{x}-x}{x^3})\\\\=4\lim\limits_{x\to0}(\frac{\frac{1}{3}(\tan{x})^3}{x^3}+\frac{\frac{1}{3}x^3}{x^3})=\frac{8}{3}$</p>
<div style="height: 10px"></div>
</li>
<li><p>$\lim\limits_{x\to0}\frac{1-\cos{x}\cdot\cos{2x}\cdot\cos{3x}}{x^2}=\lim\limits_{x\to0}(\frac{1-\cos x}{x^2}+\cos{x}\cdot\frac{1-\cos(2x)}{x^2}+\cos{x}\cdot\cos{2x}\cdot\frac{1-\cos{3x}}{x^2})\\\\=\frac{1}{2}+2+\frac{9}{2}=7$</p>
</li>
</ol>
</li>
</ul>
<hr>

<ul>
<li><p><strong>【题8】</strong>    <code>注: $1^2+2^2+\cdots+n^2=\frac&#123;n(n+1)(2n+1)&#125;&#123;6&#125;$</code></p>
<p>$\lim\limits_{n\to\infty}\sum\limits_{i=1}^{n}\frac{i^2}{n^3+n^2+n+i}$</p>
<p>利用<u>夹逼定理</u>有    $\lim\limits_{n\to\infty}\frac{1^2+2^2+\cdots+n^2}{n^3+n^2+n+n}&lt;\lim\limits_{n\to\infty}\sum\limits_{i=1}^{n}\frac{i^2}{n^3+n^2+n+i}&lt;\lim\limits_{n\to\infty}\frac{1^2+2^2+\cdots+n^2}{n^3+n^2+n+n}$</p>
<p>由于    $1^2+2^2+\cdots+n^2=\frac{n(n+1)(2n+1)}{6}$</p>
<p>可得    $\lim\limits_{n\to\infty}\frac{1^2+2^2+\cdots+n^2}{n^3+n^2+n+n}=\lim\limits_{n\to\infty}\frac{1^2+2^2+\cdots+n^2}{n^3+n^2+n+1}=\frac{1}{3}$</p>
<p>所以    $\lim\limits_{n\to\infty}\sum\limits_{i=1}^{n}\frac{i^2}{n^3+n^2+n+i}=\frac{1}{3}$</p>
</li>
</ul>
<hr>

<ul>
<li><p><strong>【题9】</strong></p>
<ol>
<li><p>$\lim\limits_{n\to\infty}\sqrt{(1+\frac{1^2}{n^2})(1+\frac{2^2}{n^2})\cdots(1+\frac{n^2}{n^2})}=e^{\lim\limits_{n\to\infty}\frac{1}{n}\sum\limits_{i=1}^{n}\ln{(1+\frac{i^2}{n^2})}}=e^{\int_0^1\ln{(1+x^2)\mathrm{d}x}}$</p>
<p>由 $\int_0^1\ln{(1+x^2)}\mathrm{d}x=x\ln{(1+x^2)}\mid_0^1-\int_0^1x\cdot\frac{2x}{1+x^2}\mathrm{d}x\\=\ln{2}-2\int_0^1(1-\frac{1}{1+x^2})\mathrm{d}x=\ln{2}-2+\frac{\pi}{2}$</p>
<p>得 $原式=e^{\ln{2}-2+\frac{\pi}{2}}$</p>
</li>
<li><p>$\lim\limits_{x\to\infty}(\frac{\sin^2\frac{\pi}{n}}{n}+\frac{\sin^2\frac{2\pi}{n}}{n}+\cdots+\frac{\sin^2\frac{n\pi}{n}}{n})=\lim\limits_{n\to\infty}\frac{1}{n}\sum\limits_{i=1}^n\sin^2\frac{i\pi}{n}=\int_0^1\sin^2\pi x\mathrm{d}x\\\\=\frac{1}{\pi}\int_0^1\sin^2\pi x\mathrm{d}(\pi x)\overset{\pi x=t}{=}\frac{1}{\pi}\int_0^{\pi}\sin^2t\mathrm{d}t\\=\frac{2}{\pi}\int_0^{\frac{\pi}{2}}\sin^2t\mathrm{d}t=\frac{2}{\pi}\int_0^{\frac{\pi}{2}}\frac{1-\cos{2t}}{2}\mathrm{d}t=\frac{2}{\pi}\cdot\frac{1}{2}\cdot\frac{\pi}{2}=\frac{1}{2}$</p>
</li>
</ol>
</li>
</ul>
<p><br></p>
<h3 id="导数-1"><a href="#导数-1" class="headerlink" title="导数"></a>导数</h3><ul>
<li><p><strong>【题1】</strong> <b>设 $y=f(x)$ 连续，且 $f(x)=2x+1+o(x-2)$，则$\mathrm{d}x\mid_{x=2}=?$ </b></p>
<p>解：因为 $f(x)$ 连续，所以有 $f(x)=2x+1+o(x-2)$ 得 $f(2)=5$</p>
<p>由 $\Delta y=f(x)-f(2)=2(x-2)+o(x-2)$ 得 $y=f(x)$ 在 $x=2$ 处可微</p>
<p>故 $\mathrm{d}y|_{x=2}=2\mathrm{d}x$</p>
</li>
</ul>
<hr>

<ul>
<li><p><strong>【题2】</strong> <strong>设函数 $y=y(x)$ 由 $\left\{\begin{array}{lcl}x=\ln(1+t)\\e^{yt}=y+2t+1\end{array}\right.$ 确定，则 $\frac{\mathrm{d}y}{\mathrm{d}x}=?.$</strong></p>
<p><strong>解：</strong>由题知 $\frac{\mathrm{d}x}{\mathrm{d}t}=\frac{1}{1+t}$</p>
<p>$e^{yt}=y+2t+1$ 两边对 $t$ 求导得 $e^{yt}\cdot(y+t\frac{\mathrm{d}y}{\mathrm{d}t})=\frac{\mathrm{d}y}{\mathrm{d}t}+2$，解得 $\frac{\mathrm{d}y}{\mathrm{d}t}=\frac{2-ye^{yt}}{te^{yt}-1}$</p>
<p>故 $\frac{\mathrm{d}y}{\mathrm{d}x}=\frac{\frac{\mathrm{d}y}{\mathrm{d}t}}{\frac{\mathrm{d}x}{\mathrm{d}t}}=\frac{(t+1)(2-ye^{yt})}{te^{yt}-1}$</p>
</li>
</ul>
<hr>

<ul>
<li><p><strong>【题3】</strong> <strong>设 $f(x)$ 连续，且对任意的 $x,y\in(-\infty,+\infty)$ 有 $f(x+y)=f(x)+f(y)+2xy$，$f^{′}(0)=1$，求 $f(x)$.</strong></p>
<p><strong>解：</strong>当 $x=0,y=0$ 时，$f(0)=2f(0)$，于是 $f(0)=0$</p>
<p>对任意的 $x\in(-\infty,+\infty)$ 有</p>
<p>$f^{′}(x)=\lim\limits_{h\to0}\frac{f(x+h)-f(x)}{h}=\lim\limits_{h\to0}\frac{f(x)+f(h)+2xh-f(x)}{h}=\lim\limits_{h\to0}\frac{f(h)-f(0)}{h}-2x=2x+1$</p>
<p>则 $f(x)=x^2+x+C$，因为 $f(0)=0$，所以 $C=0$，故 $f(x)=x+x^2$</p>
</li>
</ul>
<hr>

<ul>
<li><p><strong>【题4】</strong> <strong>设 $f(x)$ 在 $(-\infty, +\infty)$ 上连续，$f^{′}(0)=1$，且对任意的 $x,y\in(-\infty,+\infty)$ 有 $f(x+y)=f(x)f(y)$，求 $f(x)$.</strong></p>
<p><strong>解：</strong> $f^{′}(x)=\lim\limits_{h\to0}\frac{f(x+h)-f(x)}{h}=\lim\limits_{h\to0}\frac{f(x)f(h)-f(x)}{h}=f(x)\lim\limits_{h\to0}\frac{f(h)-1}{h}$</p>
<p>由 $f(0)=f^{2}(0)$ 得 $f(0)=0$ 或 $f(0)=1$</p>
<p>若 $f(0)=0$，则对任意的 $x\in(-\infty,+\infty)$，有 $f(x)=f(x)f(0)=0$</p>
<p>则 $f^{′}(x)\equiv0$，这与 $f^{′}(0)=1$ 矛盾，从而 $f(0)=1$</p>
<p>于是 $f^{′}(x)=f(x)\lim\limits_{h\to0}\frac{f(h)-1}{h}=f(x)\lim\limits_{h\to0}\frac{f(h)-f(0)}{h}=f(x)$</p>
<p>解得 $f(x)=Ce^x$，由 $f(0)=1$ 得 $C=1$，故 $f(x)=e^x$</p>
</li>
</ul>
<p><br></p>
<h3 id="中值定理与一元函数微分学"><a href="#中值定理与一元函数微分学" class="headerlink" title="中值定理与一元函数微分学"></a>中值定理与一元函数微分学</h3><ul>
<li><p><strong>【题1】</strong> <strong>数列 $\{\sqrt[n]{n}\}$ 的最大项为 ?</strong></p>
<p><strong>解：</strong>设 $f(x)=x^{\frac{1}{x}}=e^{\frac{\ln{x}}{x}}, f^{′}(x)=\frac{1-\ln{x}}{x^2}e^{\frac{\ln{x}}{x}}$</p>
<p>令 $f^{′}(x)=0$ 得 $x=e$</p>
<p>当 $0\lt x\lt e$ 时，$f^{′}(x)&gt;0$，$f(x)$ 为单调递增区间；</p>
<p>当 $x&gt;e$ 时，$f^{′}(x)&lt;0$，$f(x)$ 为单调递减区间</p>
<p>则 $\{\sqrt[n]{n}\}$ 的最大项为 $\sqrt{2}$ 或 $\sqrt[3]{3}$，由于 $\sqrt{2}=\sqrt[6]{8}&lt;\sqrt[6]{9}=\sqrt[3]{3}$，故 $\{\sqrt[n]{n}\}$ 的最大项为 $\sqrt[3]{3}$</p>
</li>
</ul>
<hr>
<ul>
<li><p><strong>【题2】</strong> <b>曲线 $L:\left\{\begin{array}{lcl}x=a(t-\sin{t})\\y=a(1-\cos{t})\end{array}\right.,(a&gt;0)$ 在 $t=\frac{\pi}{2}$ 对应处的曲率为</b></p>
<blockquote>
<p>  <strong>曲率公式有：</strong>$K=\frac{|y^{′′}|}{(1+y^{′2})^{\frac{3}{2}}}$，$\rho=\frac{1}{K}$</p>
</blockquote>
<p><strong>解：</strong> $\frac{\mathrm{d}y}{\mathrm{d}x}=\frac{\mathrm{d}y/\mathrm{d}t}{\mathrm{d}x/\mathrm{d}t}=\frac{\sin{t}}{1-\cos{t}}$，$\frac{\mathrm{d}y}{\mathrm{d}x}|_{t=\frac{\pi}{2}}=1$</p>
<p>$\frac{\mathrm{d}^2y}{\mathrm{d}x^2}=\frac{\mathrm{d}}{\mathrm{d}x^2}(\frac{\sin{t}}{1-\cos{t}})=\frac{\frac{\cos{t}-1}{(1-\cos{t})^2}}{a(1-\cos{t})}=-\frac{1}{a(1-\cos{t})^2}$，$\frac{\mathrm{d}^2y}{\mathrm{d}x^2}|_{t=\frac{\pi}{2}}=-\frac{1}{a}$</p>
<p>则 $t=\frac{\pi}{2}$ 处的曲率为 $K=\frac{|\frac{\mathrm{d}^2y}{\mathrm{d}x^2}|}{[1+(\frac{\mathrm{d}y}{\mathrm{d}x})^2]^\frac{3}{2}}=\frac{1}{2\sqrt{2}a}$</p>
</li>
</ul>
<hr>
<ul>
<li><p><strong>【题3】</strong> <strong>曲线 $y=\int_0^xe^{-t^2}\mathrm{d}t$ 的水平渐近线为 ?</strong></p>
<p><strong>解：</strong> 由 $\lim\limits_{x\to+\infty}y=\int_0^{+\infty}e^{-t^2}\mathrm{d}t\overset{t^2=u}=\int_0^{+\infty}e^u\cdot\frac{1}{2\sqrt{u}}\mathrm{d}u=\frac{1}{2}\Gamma(\frac12)=\frac{\sqrt{\pi}}{2}$ </p>
<p>得 $y=\frac{\sqrt{\pi}}{2}$ 为曲线的一条水平渐近线</p>
<p>由 $\lim\limits_{x\to-\infty}y=\int_0^{-\infty}e^{-t^2}\mathrm{d}t=-\int^0_{-\infty}e^{-t^2}\mathrm{d}t=-\int_0^{+\infty}e^{-t^2}\mathrm{d}t=\frac{\sqrt{\pi}}{2}$ </p>
<p>得 $y=-\frac{\sqrt{\pi}}{2}$ 为曲线的另一条水平渐近线</p>
<blockquote>
<p>  <strong>在实数域上伽马函数定义为：</strong> $\Gamma(x)=\int_0^{+\infty}\Box^{x-1}e^{-\Box}\mathrm{d}\Box$</p>
<ol>
<li>$\Gamma(1)=1$，$\Gamma(\frac{1}{2})=\sqrt{\pi}$，$\Gamma(-\frac{1}{2})=-2\sqrt{\pi}$，$\Gamma(\frac{3}{2})=\frac{\pi}{2}$，$\Gamma(n+\frac{1}{2})=\frac{(2n)!}{n!4^n}\sqrt\pi$</li>
<li>$\Gamma(x+1)=x\Gamma(x)$</li>
<li>x-1为自然数时 $\Gamma(n+1)=n!$</li>
</ol>
</blockquote>
</li>
</ul>
<p><br></p>
<p><br></p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>高等数学</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/2022/04/10/DataStructure/</url>
    <content><![CDATA[<p><em><u>计算机科班、考研的重要课程</u></em></p>
<p>数据结构讨论的是数据的<strong><em>逻辑结构</em></strong>、<strong><em>存储方式</em></strong>以及相关操作</p>
<span id="more"></span>
<p><br><br></p>
<h1 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h1><h2 id="数据结构的基本概念与术语"><a href="#数据结构的基本概念与术语" class="headerlink" title="数据结构的基本概念与术语"></a>数据结构的基本概念与术语</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>数据：</strong>数据是信息的<strong>载体</strong>，描述客观事物属性的<strong>数</strong>、<strong>字符</strong>及所有能输入到计算机中并被计算机程序识别和处理的<strong>符号的集合</strong>。数据是计算机程序加工的<strong>原料</strong>。</p>
<p><strong>数据元素：</strong>是数据的<strong>基本单位</strong>。一个数据元素可由若干个数据项组成。</p>
<p><strong>结构：</strong>各个元素之间的关系。</p>
<p><strong>数据结构：</strong>相互之间存在<strong>一种</strong>或<strong>多种</strong>特定关系的<strong>数据元素的集合</strong>。</p>
<p><strong>数据对象：</strong>具有<strong>相同性质</strong>的<strong>数据元素的集合</strong>。</p>
<p><strong>数据类型：</strong>一个值的集合和定义在集合上的一组操作的总称。</p>
<ol>
<li><strong>原子类型：</strong>值不可再分</li>
<li><strong>结构类型：</strong>值可以再分解为若干成分（分量）的数据类型</li>
<li><b>抽象数据类型(<code>ADT</code>)</b>：抽象数据组织及与之相关的操作。<code>ADT</code>用数学化的语言定义数据的逻辑结构、定义运算。与具体的实现即存储结构无关。定义一个<code>ADT</code>就是定义了数据的逻辑机构和运算，也就是定义了一个数据结构。</li>
</ol>
<h3 id="数据结构三要素"><a href="#数据结构三要素" class="headerlink" title="数据结构三要素"></a>数据结构三要素</h3><ol>
<li><p><strong>逻辑结构</strong></p>
<p>它与数据的存储无关，是独立于计算机的。</p>
<img src="/2022/04/10/DataStructure/ds_LogicalStructure.png" class="" title="数据的逻辑结构">
<ul>
<li>集合（非线性）</li>
<li>线性结构</li>
<li>树形结构（非线性）</li>
<li>网状结构或图状结构（非线性）</li>
</ul>
</li>
<li><p><strong>存储结构</strong></p>
<p>指的是数据在计算机中的存储方式。</p>
<p>数据的存储结构主要有：</p>
<ul>
<li>顺序存储</li>
<li>链式存储</li>
<li>索引存储</li>
<li>散列存储</li>
</ul>
</li>
<li><p><strong>运算集合</strong></p>
<p>对数据的处理必定涉及到相关的运算。</p>
</li>
</ol>
<p><br></p>
<p><u><strong>数据结构</strong></u>就是指按照一定的<strong><em>逻辑结构</em></strong>组成的一批数据，使用某种<strong><em>存储结构</em></strong>将这批数据存储于计算机中，并在这些数据上定义了一个<strong><em>运算集合</em></strong></p>
<p><br></p>
<h2 id="算法与算法分析"><a href="#算法与算法分析" class="headerlink" title="算法与算法分析"></a>算法与算法分析</h2><h3 id="基本概念和特征"><a href="#基本概念和特征" class="headerlink" title="基本概念和特征"></a>基本概念和特征</h3><p>算法(Algorithm)是对特定问题求解步骤的一种描述，它是指令的有限序列。</p>
<p>算法满足5个特征：</p>
<ol>
<li><strong>有穷性：</strong>个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成</li>
<li><strong>确定性：</strong>算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出</li>
<li><strong>输入：</strong>算法可以有0个或多个输入</li>
<li><strong>输出：</strong>算法一定有输出的结果</li>
<li><strong>可行性：</strong>算法中的运算都必须是可以实现的</li>
</ol>
<p>通常，好的算法应该考虑到：</p>
<ol>
<li><strong>正确性</strong></li>
<li><strong>可读性</strong></li>
<li><strong>健壮性：</strong>输入非法数据时，算法能适当地做出反应或进行处理，而不会产生莫名其妙的输出结果</li>
<li><strong>高效率和低存储</strong></li>
</ol>
<p><br></p>
<p><strong>程序</strong> = <strong>数据结构</strong> + <strong>算法</strong></p>
<ul>
<li><strong>数据结构：</strong>如何把现实世界的问题信息化，将信息存进计算机，同时还要实现对数据结构的基本操作</li>
<li><strong>算法：</strong>如何处理这些信息，以解决实际问题</li>
</ul>
<p><br></p>
<h3 id="时间复杂度和空间复杂度"><a href="#时间复杂度和空间复杂度" class="headerlink" title="时间复杂度和空间复杂度"></a>时间复杂度和空间复杂度</h3><p>一个算法的优劣主要从 <u><strong>时间复杂度</strong>（执行时间）</u>和所需要占用的 <u><strong>空间复杂度</strong>（存储空间）</u>两方面来衡量</p>
<blockquote>
<p>  算法估计：</p>
<p>  和机器性能有关，和编程语言有关，和编译程序产生的机器指令质量有关，有些算法不能事后统计。</p>
</blockquote>
<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>一个语句的频度是该语句在算法中被重复执行的次数。</p>
<p>算法中所有语句的频度之和记为<b>T(n)</b>，他是该算法问题规模n的函数，时间复杂度主要是分析T(n)的数量级。</p>
<p>时间复杂度一般总是考虑在最坏情况下的时间复杂度，以保证算法的运行时间不会比它更长。</p>
<p>分析程序的时间复杂度时，有两条规则：</p>
<ol>
<li><p><strong>加法规则</strong></p>
<p>T(n) = T<sub>1</sub>(n) + T<sub>2</sub>(n) = O(f(n)) + O(g(n)) = O(max(f(n), g(n)))</p>
</li>
<li><p><strong>乘法规则</strong></p>
<p>T(n) = T<sub>1</sub>(n) × T<sub>2</sub>(n) = O(f(n)) × O(g(n)) = O(f(n) × g(n))</p>
</li>
</ol>
<p><br></p>
<p>常见的渐进时间复杂度</p>
<p>​    O(1) &lt; O(log<sub>2</sub>n) &lt; O(n) &lt; O(nlog<sub>2</sub>n) &lt; O(n<sup>2</sup>) &lt; O(n<sup>3</sup>) &lt; O(2<sup>n</sup>) &lt; O(n!) &lt; O(n<sup>n</sup>)</p>
<p><br></p>
<p><strong>【注】</strong></p>
<ol>
<li>忽略问题规模更低阶的部分，只保留最高阶。主要是分析T(n)的数量级。</li>
<li>常数项可以忽略。</li>
<li>只需要挑循环中的一个基本操作分析它的执行次数与n的关系</li>
<li>多层嵌套循环，只需要关注最深层循环循环了多少次</li>
<li>一般来说我们只会度量最坏时间复杂度和平均时间复杂度</li>
</ol>
<p><br></p>
<h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>空间复杂度<b>S(n)</b>定义为该算法所耗费的存储空间，它是问题规模n的函数。</p>
<p>计算方法：</p>
<ol>
<li>找到与问题规模相关的空间大小变量</li>
<li>分析所占空间x与问题规模n的关系</li>
<li>x的数量级O(n)就是算法空间复杂度</li>
</ol>
<p><br></p>
<p><br></p>
<h1 id="线性表及其顺序存储"><a href="#线性表及其顺序存储" class="headerlink" title="线性表及其顺序存储"></a>线性表及其顺序存储</h1><h2 id="顺序表及其应用"><a href="#顺序表及其应用" class="headerlink" title="顺序表及其应用"></a>顺序表及其应用</h2><p>采用<strong>顺序存储</strong>方式来存储的<strong>线性表</strong>称为<strong>顺序表</strong>。</p>
<p>顺序表是将表中的结点一次存放在计算机内存中一组地址连续的存储单元中。</p>
<img src="/2022/04/10/DataStructure/sequence_1.png" class="" title="顺序表">
<p>顺序表的<code>C语言</code>实现</p>
<p><u>定义顺序表结构体</u></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @desc 顺序表结构体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> datatype;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    datatype data[MAXSIZE];</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">&#125; sequence_list;</span><br></pre></td></tr></table></figure>
<p><u>初始化顺序表</u></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * @desc 初始化顺序表</span></span><br><span class="line"><span class="comment"> * @param slt: 需要初始化的顺序表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(sequence_list *slt)</span> &#123;</span><br><span class="line">    slt-&gt;size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><u>判断顺序表是否为空</u></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @desc 判断顺序表是否为空</span></span><br><span class="line"><span class="comment"> * @param slt: 需要查寻的顺序表</span></span><br><span class="line"><span class="comment"> * @return Y~1; N~0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">empty</span><span class="params">(sequence_list slt)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> slt.size == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><u>尾插法插入结点</u></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * @desc 尾插法</span></span><br><span class="line"><span class="comment"> * @param slt: 需要修改的顺序表</span></span><br><span class="line"><span class="comment"> * @param x: 需要插入的结点值</span></span><br><span class="line"><span class="comment"> * @return 是否可以添加(Y~1; N~0)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">append</span><span class="params">(sequence_list *slt, datatype x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (slt-&gt;size == MAXSIZE) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    slt-&gt;data[slt-&gt;size] = x;</span><br><span class="line">    slt-&gt;size++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><u>打印各个结点</u></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @desc 打印顺序表</span></span><br><span class="line"><span class="comment"> * @param slt: 需要打印的顺序表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">output</span><span class="params">(sequence_list slt)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!slt.size) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The list is empty\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; slt.size; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%5d&quot;</span>, slt.data[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><u>寻找第一个值为x的结点</u></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @desc 寻找第一个值为x的结点</span></span><br><span class="line"><span class="comment"> * @param slt: 需要查找的顺序表</span></span><br><span class="line"><span class="comment"> * @param x: 需要查找的结点值</span></span><br><span class="line"><span class="comment"> * @return 结点下标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">find_first</span><span class="params">(sequence_list slt, datatype x)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; slt.size &amp;&amp; slt.data[i] != x) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i &lt; slt.size ? i : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><u>寻找制定下标i所对应的结点值</u></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @desc 寻找制定下标i所对应的结点值</span></span><br><span class="line"><span class="comment"> * @param slt: 需要查找的顺序表</span></span><br><span class="line"><span class="comment"> * @param i: 目标结点下标</span></span><br><span class="line"><span class="comment"> * @return 结点值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">datatype <span class="title function_">get</span><span class="params">(sequence_list slt, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= slt.size) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;index out of range\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> slt.data[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><u>在指定位置插入结点</u></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @desc 在顺序表的对应下标i插入值为x的结点</span></span><br><span class="line"><span class="comment"> * @param slt: 需要修改的顺序表</span></span><br><span class="line"><span class="comment"> * @param x: 需要插入的结点值</span></span><br><span class="line"><span class="comment"> * @param i: 需要插入的结点下标</span></span><br><span class="line"><span class="comment"> * @return 是否插入成功(Y~1; N~0)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">insert</span><span class="params">(sequence_list *slt, datatype x, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (slt-&gt;size == MAXSIZE) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The list is full&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt; slt-&gt;size) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;index out of range\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = slt-&gt;size; j &gt; i; j--) &#123;</span><br><span class="line">        slt-&gt;data[j] = slt-&gt;data[j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    slt-&gt;size++;</span><br><span class="line">    slt-&gt;data[i] = x;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><u>删除指定位置结点</u></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @desc 删除顺序表中下标为i的结点</span></span><br><span class="line"><span class="comment"> * @param slt: 需要修改的顺序表</span></span><br><span class="line"><span class="comment"> * @param i: 目标结点下标</span></span><br><span class="line"><span class="comment"> * @return 是否删除成功(Y~1; N~0)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">del_index</span><span class="params">(sequence_list *slt, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (slt-&gt;size == MAXSIZE) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The list is full&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt; slt-&gt;size) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;index out of range\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; slt-&gt;size; j++) &#123;</span><br><span class="line">        slt-&gt;data[j] = slt-&gt;data[j + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    slt-&gt;size--;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="栈的概念及其应用"><a href="#栈的概念及其应用" class="headerlink" title="栈的概念及其应用"></a>栈的概念及其应用</h2><p><strong>栈</strong>(stack)是特殊的线性表，插入、删除在同一端进行。进行插入、删除的那一段称为栈顶，另一端为栈底。插入操作称为<u><strong>进栈</strong>(push)</u>，删除操作称为<u><strong>出栈</strong>(pop)</u>。</p>
<p>栈具有先进后出（后进先出）的特点(First In Last Out, FILO)</p>
<p>顺序栈的实现与顺序表一致(<code>C语言</code>)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @desc 定义顺序栈结构体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> datatype;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    datatype data[MAXSIZE];</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">&#125; sequence_stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @desc 初始化栈</span></span><br><span class="line"><span class="comment"> * @param ssk: 顺序栈指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(sequence_stack *ssk)</span> &#123;</span><br><span class="line">    ssk-&gt;size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @desc 判断栈是否为空</span></span><br><span class="line"><span class="comment"> * @param ssk: 顺序栈</span></span><br><span class="line"><span class="comment"> * @return Y~1; N~0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">is_empty</span><span class="params">(sequence_stack ssk)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ssk.size == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @desc 返回栈顶值</span></span><br><span class="line"><span class="comment"> * @param ssk: 顺序栈</span></span><br><span class="line"><span class="comment"> * @return 返回栈顶值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">datatype <span class="title function_">read_head</span><span class="params">(sequence_stack ssk)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ssk.data[ssk.size - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @desc 打印栈</span></span><br><span class="line"><span class="comment"> * @param ssk: 顺序栈</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">output</span><span class="params">(sequence_stack ssk)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ssk.size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The stack is empty&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ssk.size; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%5c&quot;</span>, ssk.data[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @desc 进栈</span></span><br><span class="line"><span class="comment"> * @param ssk: 顺序栈指针</span></span><br><span class="line"><span class="comment"> * @param x: 需要进栈的值</span></span><br><span class="line"><span class="comment"> * @return 是否成功 Y~1; N~0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">push</span><span class="params">(sequence_stack *ssk, datatype x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ssk-&gt;size &gt;= MAXSIZE) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The stack is full\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ssk-&gt;data[ssk-&gt;size++] = x;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @desc 出栈</span></span><br><span class="line"><span class="comment"> * @param ssk: 顺序栈指针</span></span><br><span class="line"><span class="comment"> * @return 是否成功 Y~1; N~0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(sequence_stack *ssk)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ssk-&gt;size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The stack is empty&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ssk-&gt;size--;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>【实例】</strong></p>
<p><u>算术表达式求值</u></p>
<p>表达式类型有三种：</p>
<ul>
<li><p>中缀表达式 (日常用的表达式)</p>
</li>
<li><p>前缀表达式</p>
</li>
<li><p><strong>后缀表达式</strong></p>
<p>从左到右执行，当遇到一个操作符，则将<u>操作符前的两个数</u>弹出执行对应操作</p>
</li>
</ul>
<p>[例]：中缀、后缀转换        </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>中缀表达式</th>
<th>后缀表达式</th>
</tr>
</thead>
<tbody>
<tr>
<td>3 - 5 * 2</td>
<td>3 5 2 * -</td>
</tr>
<tr>
<td>(3 - 5) * 2</td>
<td>3 5 - 2 *</td>
</tr>
<tr>
<td>3 / (5 * 2 + 1)</td>
<td>3 5 2 * 1 + /</td>
</tr>
</tbody>
</table>
</div>
<p><br></p>
<h2 id="队列的概念及其应用"><a href="#队列的概念及其应用" class="headerlink" title="队列的概念及其应用"></a>队列的概念及其应用</h2><p><strong>队列</strong>(Queue)</p>
<p>队列的特点为先进先出(FIFO，First In First Out)，<strong>插入</strong>(rear端)和<strong>删除</strong>(front端)在两端进行。当<code>front == rear</code>时，队列中没有任何元素，称为空队列；当<code>rear == MAXSIZE</code>时，队列满。</p>
<p><br></p>
<p><strong>循环队列</strong>(Circular Queue)</p>
<p>循环队列就是将<u>队列</u>存储空间的最后一个位置绕到第一个位置，形成逻辑上的环状空间，供队列循环使用。</p>
<p>在循环队列结构中，当存储空间的最后一个位置已被使用而再要进入队运算时，只需要存储空间的第一个位置空闲，便可将元素加入到第一个位置，即将存储空间的第一个位置作为队尾。</p>
<p>在循环队列中，当队列为空时，有<code>front == rear</code>，而当所有队列空间全占满时，也有<code>fron == rear</code>。为了区别这两种情况，规定循环队列最多只能有<code>MAXSIZE - 1</code>个队列元素，当循环队列中只剩下一个空存储单元时，队列就已经满了。因此，队列判空的条件是front=rear，而队列判满的条件是<code>front = (rear + 1) % MAXSIZE</code>。</p>
<p>顺序队列（循环队列）的实现与顺序表和顺序栈也是类似的，这里就不展示了</p>
<p><br></p>
<p><br></p>
<h1 id="线性表及其链式存储"><a href="#线性表及其链式存储" class="headerlink" title="线性表及其链式存储"></a>线性表及其链式存储</h1><h2 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h2><p>链式数据存储是指数据采用链式存储结构进行存储，存储密度比顺序存储结构小，可以更加灵活的对内存进行使用。</p>
<img src="/2022/04/10/DataStructure/sequence_link.png" class="" title="顺序存储与链式存储的区别">
<p><br></p>
<h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><p>是<u>链式存储</u>对的一种形式，其结点一般含有<code>info</code>（存放数据信息）和<code>next</code>（后继结点地址指针）两个域。</p>
<img src="/2022/04/10/DataStructure/link_1.png" class="">
<p><u>单链表结构体实现</u>(<code>C语言</code>)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @desc 单链表结构体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> datatype;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">link_node</span> &#123;</span></span><br><span class="line">    datatype info;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; node;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="带头结点的单链表及其应用"><a href="#带头结点的单链表及其应用" class="headerlink" title="带头结点的单链表及其应用"></a>带头结点的单链表及其应用</h2><p>带头结点的单链表与不带头结点的单链表区别在于<u>head结点</u>与后续结点的结构是一致的。</p>
<img src="/2022/04/10/DataStructure/link_2.png" class="" title="带头结点的单链表">
<p>带头结点单链表的<code>C语言</code>实现</p>
<p><u>初始化单链表</u></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @desc 初始化头结点</span></span><br><span class="line"><span class="comment"> * @return 头结点head</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">node *<span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    node *head = (node*) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(node));</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><u>输出单链表</u></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @desc 打印单链表</span></span><br><span class="line"><span class="comment"> * @param head: 需要打印的单链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">output</span><span class="params">(node *head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The linked list is empty&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node *p = head-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The linked list&#x27;s info: \n&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%5d&quot;</span>, p-&gt;info);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><u>查找单链表中的第i个结点</u></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @desc 查找单链表中的第i个结点</span></span><br><span class="line"><span class="comment"> * @param head: 需要进行查找操作的单链表</span></span><br><span class="line"><span class="comment"> * @param i: 需要查找的位置下标</span></span><br><span class="line"><span class="comment"> * @return 指定结点地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">node *<span class="title function_">find</span> <span class="params">(node *head, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Unable to find node %d, operation failed\n&quot;</span>, i);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    node *p = head;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; j != i) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><u>在指定位置i后面插入值为x的新节点</u></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @desc 在指定位置i后面插入值为x的新节点</span></span><br><span class="line"><span class="comment"> * @param head: 需要进行插入操作的单链表</span></span><br><span class="line"><span class="comment"> * @param x: 新节点的值</span></span><br><span class="line"><span class="comment"> * @param i: 需要进行插入操作的位置下标</span></span><br><span class="line"><span class="comment"> * @return 操作完成的单链表头结点地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">node *<span class="title function_">insert</span><span class="params">(node *head, datatype x, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    node *q = find(head, i);</span><br><span class="line">    <span class="keyword">if</span> (!q) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Unable to find node %d, operation failed\n&quot;</span>, i);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    node *p = (node*) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(node));</span><br><span class="line">    p-&gt;info = x;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    q-&gt;next = p;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><u>删除单链表中第一个值为x的结点</u></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @desc 删除单链表中第一个值为x的结点</span></span><br><span class="line"><span class="comment"> * @param head: 需要进行删除操作的单链表</span></span><br><span class="line"><span class="comment"> * @param x: 需要删除的节点的值</span></span><br><span class="line"><span class="comment"> * @return 操作完成的单链表头结点地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">node *<span class="title function_">del</span><span class="params">(node *head, datatype x)</span> &#123;</span><br><span class="line">    node *pre = head, *p = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; p-&gt;info != x) &#123;</span><br><span class="line">        pre = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">if</span> (p) &#123;</span><br><span class="line">        pre-&gt;next = p-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Unable to find node with value %d, operation failed\n&quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>带头结点的单链表与不带头结点的单链表相比的最明显的<u>优势</u>是可以不用单独考虑<u>第一个</u>结点的操作特殊性问题</p>
<p><br></p>
<h2 id="循环单链表与双链表"><a href="#循环单链表与双链表" class="headerlink" title="循环单链表与双链表"></a>循环单链表与双链表</h2><h3 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h3><p><strong>循环单链表</strong>即在<u>普通单链表</u>的基础上，在最后一个结点的<code>next</code>指向了头结点而不是为<code>NULL</code></p>
<img src="/2022/04/10/DataStructure/link_3.png" class="" title="循环单链表">
<h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><p><strong>双链表</strong>则是在<u>普通单链表</u>的基础上，在单链表的每个结点上都增加了一个储存前驱结点地址的变量<code>pre</code></p>
<img src="/2022/04/10/DataStructure/link_4.png" class="" title="双链表">
<p>双链表虽然可以向前寻找，但是需要多分配一个指针存储空间，对内存利用率低。</p>
<p><strong>头结点的<code>C语言</code>实现</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @desc 单链表结构体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> datatype;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dlink_node</span> &#123;</span></span><br><span class="line">    datatype info;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dlink_node</span> *<span class="title">pre</span>, *<span class="title">next</span>;</span></span><br><span class="line">&#125; d_node;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="链式栈与链式队列"><a href="#链式栈与链式队列" class="headerlink" title="链式栈与链式队列"></a>链式栈与链式队列</h2><ul>
<li><p><strong>链式栈</strong></p>
<p>与顺序栈仅在<u>存储方式</u>上不一样，但是一样为先进后出（后进先出）的特点(First In Last Out, FILO)</p>
</li>
<li><p><strong>链式队列</strong></p>
<p>链式队列就是一个只能在<code>front</code>端插入和<code>rear</code>端删除的单链表，相对平常的单链表需要多创建一个可以存储<code>front</code>和<code>rear</code>地址的结点</p>
<p>链式队列相对顺序队列，不会出现<u>队列空间占满</u>的情况出现</p>
<img src="/2022/04/10/DataStructure/link_queue.png" class="" title="链式队列">
<p><strong>链式队列的<code>C语言</code>实现</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @desc 单链表结构体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> datatype;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">link_node</span> &#123;</span></span><br><span class="line">    datatype info;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; node;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @desc 队列结构体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    node *front, *rear;</span><br><span class="line">&#125; <span class="built_in">queue</span>;</span><br></pre></td></tr></table></figure>
<p><u>其他初始化、插入删除等操作与单链表类似！</u></p>
</li>
</ul>
<p><br></p>
<p><br></p>
<h1 id="字符串、数组与特殊矩阵"><a href="#字符串、数组与特殊矩阵" class="headerlink" title="字符串、数组与特殊矩阵"></a>字符串、数组与特殊矩阵</h1><h2 id="字符串与模式匹配"><a href="#字符串与模式匹配" class="headerlink" title="字符串与模式匹配"></a>字符串与模式匹配</h2><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h2 id="特殊矩阵的压缩存储"><a href="#特殊矩阵的压缩存储" class="headerlink" title="特殊矩阵的压缩存储"></a>特殊矩阵的压缩存储</h2><h2 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h2><p><br></p>
<p><br></p>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><h2 id="递归的基本概念与递归程序设计"><a href="#递归的基本概念与递归程序设计" class="headerlink" title="递归的基本概念与递归程序设计"></a>递归的基本概念与递归程序设计</h2><h2 id="递归程序设计执行过程的分析"><a href="#递归程序设计执行过程的分析" class="headerlink" title="递归程序设计执行过程的分析"></a>递归程序设计执行过程的分析</h2><h2 id="递归程序设计执行过程的分析-1"><a href="#递归程序设计执行过程的分析-1" class="headerlink" title="递归程序设计执行过程的分析"></a>递归程序设计执行过程的分析</h2><h2 id="递归程序到非递归程序的转换"><a href="#递归程序到非递归程序的转换" class="headerlink" title="递归程序到非递归程序的转换"></a>递归程序到非递归程序的转换</h2><p><br></p>
<p><br></p>
<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p><br></p>
<p><br></p>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><h2 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h2><h2 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h2><h2 id="穿插二叉树"><a href="#穿插二叉树" class="headerlink" title="穿插二叉树"></a>穿插二叉树</h2><h2 id="树、森林和二叉树的转换"><a href="#树、森林和二叉树的转换" class="headerlink" title="树、森林和二叉树的转换"></a>树、森林和二叉树的转换</h2><p><br></p>
<p><br></p>
<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h2><h2 id="存储结构-2"><a href="#存储结构-2" class="headerlink" title="存储结构"></a>存储结构</h2><h2 id="遍历-2"><a href="#遍历-2" class="headerlink" title="遍历"></a>遍历</h2><h2 id="生成树与最小生成树"><a href="#生成树与最小生成树" class="headerlink" title="生成树与最小生成树"></a>生成树与最小生成树</h2><h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><h2 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h2><p><br></p>
<p><br></p>
<h1 id="检索"><a href="#检索" class="headerlink" title="检索"></a>检索</h1><h2 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h2><h2 id="线性表的检索"><a href="#线性表的检索" class="headerlink" title="线性表的检索"></a>线性表的检索</h2><h2 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h2><h2 id="平衡二叉排序树"><a href="#平衡二叉排序树" class="headerlink" title="平衡二叉排序树"></a>平衡二叉排序树</h2><h2 id="Huffman树"><a href="#Huffman树" class="headerlink" title="Huffman树"></a>Huffman树</h2><h2 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h2><h2 id="散列表的检索"><a href="#散列表的检索" class="headerlink" title="散列表的检索"></a>散列表的检索</h2><h2 id="查找算法的分析及应用"><a href="#查找算法的分析及应用" class="headerlink" title="查找算法的分析及应用"></a>查找算法的分析及应用</h2><p><br></p>
<p><br></p>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="基本概念-4"><a href="#基本概念-4" class="headerlink" title="基本概念"></a>基本概念</h2><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><h2 id="二路归并排序-merge-sort"><a href="#二路归并排序-merge-sort" class="headerlink" title="二路归并排序(merge sort)"></a>二路归并排序(merge sort)</h2><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><h2 id="排序算法的比较"><a href="#排序算法的比较" class="headerlink" title="排序算法的比较"></a>排序算法的比较</h2><h2 id="内部排序算法的应用"><a href="#内部排序算法的应用" class="headerlink" title="内部排序算法的应用"></a>内部排序算法的应用</h2><p><br></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>C语言</tag>
        <tag>顺序表</tag>
        <tag>链表</tag>
        <tag>栈</tag>
        <tag>队列</tag>
        <tag>递归</tag>
        <tag>数组</tag>
        <tag>字符串</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
        <tag>图</tag>
        <tag>检索</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2022/04/04/DynamicProgramming/</url>
    <content><![CDATA[<h4 id="什么是动态规划"><a href="#什么是动态规划" class="headerlink" title="什么是动态规划"></a><em><a href="https://www.zhihu.com/question/23995189">什么是动态规划</a></em></h4><p>动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。</p>
<p>其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。</p>
<span id="more"></span>
<h4 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a><a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/">746. 使用最小花费爬楼梯</a></h4><p>假设数组<code>cost</code>的长度为 <strong>n</strong> ，则 <strong>n</strong> 个阶梯分别对应下标 <code>0</code> 到 <code>n-1</code>，楼层顶部对应下标 <strong>n</strong>，问题等价于计算达到下标 <strong>n</strong> 的最小花费</p>
<p>由于可以选择下标 <strong>0</strong> 或 <strong>1</strong> 作为初始阶梯，因此有 <code>dp[0]</code> <strong>=</strong> <code>dp[1]</code> <strong>=</strong> <code>0</code></p>
<p>当<code>2 ≤ i ≤ n</code> 时，可以从下标为 <code>i - 1</code> 或者 <code>i - 2</code> 获取花费的金额，选取两者中最小的那个加上当前已花费的金额</p>
<p><strong>Java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostClimbingStairs</span><span class="params">(<span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="number">0</span>, curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= cost.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> Math.min(curr + cost[i - <span class="number">1</span>], prev + cost[i - <span class="number">2</span>]);</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Python</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minCostClimbingStairs</span>(<span class="params">self, cost: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        prev = <span class="number">0</span></span><br><span class="line">        curr = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">len</span>(cost) + <span class="number">1</span>):</span><br><span class="line">            minTag = <span class="built_in">min</span>(curr + cost[i - <span class="number">1</span>], prev + cost[i - <span class="number">2</span>])</span><br><span class="line">            prev = curr</span><br><span class="line">            curr = minTag</span><br><span class="line">        <span class="keyword">return</span> curr</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213. 打家劫舍 II"></a><a href="https://leetcode-cn.com/problems/house-robber-ii/">213. 打家劫舍 II</a></h4><p>首先考虑最简单的情况。如果只有一间房屋，则偷窃该房屋，可以偷窃到最高总金额。如果只有两间房屋，则由于两间房屋相邻，不能同时偷窃，只能偷窃其中的一间房屋，因此选择其中金额较高的房屋进行偷窃，可以偷窃到最高总金额。</p>
<p>当房间数超过两间，这我们可以按照<strong>不偷第一间</strong>和<strong>不偷最后一间</strong>两种情况进行区分。</p>
<ul>
<li><strong>不偷第一间</strong>，则下标范围为 <code>(0, n - 2)</code></li>
<li><strong>不偷最后一间</strong>，则下标范围为<code>(1, n - 1)</code></li>
</ul>
<p>在范围内查找最大值即可</p>
<p><strong>Java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (length == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(robFlag(<span class="number">0</span>, length - <span class="number">2</span>, nums), robFlag(<span class="number">1</span>, length - <span class="number">1</span>, nums));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">robFlag</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curr</span> <span class="operator">=</span> nums[start], max = Math.max(nums[start], nums[start + <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start + <span class="number">2</span>; i &lt;= end; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> max;</span><br><span class="line">            max = Math.max(curr + nums[i], max);</span><br><span class="line">            curr = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="740-删除并获得点数"><a href="#740-删除并获得点数" class="headerlink" title="740. 删除并获得点数"></a><a href="https://leetcode-cn.com/problems/delete-and-earn/">740. 删除并获得点数</a></h4><p>每次操作中，选择任意一个 <code>nums[i]</code> ，删除它和所有等于 <code>nums[i] - 1</code> 和 <code>nums[i] + 1</code> 的元素，最后获得 <code>nums[i]</code> 的点数。</p>
<p>这道题将所有数字的点数相加后，会变成打家劫舍问题。因为<code>nums[i]</code>的范围为<code>1 ~ 10000</code>，则我们可以创建一个长度为<strong>10000</strong>的数组，然后因为相邻数字会被删除，可看做相邻数字不能被打劫</p>
<p><strong>Java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteAndEarn</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span>[] trans = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10001</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            trans[num] += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>, q = trans[<span class="number">1</span>], max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; trans.length; i++) &#123;</span><br><span class="line">            max = Math.max(q, p + trans[i]);</span><br><span class="line">            p = q;</span><br><span class="line">            q = max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="918-环形子数组的最大和"><a href="#918-环形子数组的最大和" class="headerlink" title="918. 环形子数组的最大和"></a><a href="https://leetcode-cn.com/problems/maximum-sum-circular-subarray/">918. 环形子数组的最大和</a></h4><p><strong>Kadane 算法</strong></p>
<p>这题一共有两种情况（也就是相当于比53题多了一种最大子数组和是首尾连接的情况）</p>
<ul>
<li><strong>第一种情况：</strong>这个子数组不是环状的，就是说首尾不相连。</li>
<li><strong>第二种情况：</strong>这个子数组一部分在首部，一部分在尾部，我们可以将这第二种情况转换成第一种情况</li>
</ul>
<p>如下图：</p>
<img src="/2022/04/04/DynamicProgramming/918_1.png" class="">
<p>所以这最大的环形子数组和 = <strong>max(最大子数组和，数组总和-最小子数组和)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubarraySumCircular</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>, maxSum = nums[<span class="number">0</span>], minSum = nums[<span class="number">0</span>], currMax = <span class="number">0</span>, currMin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            currMax = Math.max(currMax + num, num);</span><br><span class="line">            currMin = Math.min(currMin + num, num);</span><br><span class="line">            maxSum = Math.max(currMax, maxSum);</span><br><span class="line">            minSum = Math.min(currMin, minSum);</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum &gt; <span class="number">0</span> ? Math.max(maxSum, sum - minSum) : maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="1014-最佳观光组合"><a href="#1014-最佳观光组合" class="headerlink" title="1014. 最佳观光组合"></a><a href="https://leetcode-cn.com/problems/best-sightseeing-pair/">1014. 最佳观光组合</a></h4><p>稍微给这个公式变形成 <code>A[i]+i+A[j]-j</code> ，这样就可以看成是左 <code>A[i]+i</code> 和右 <code>A[j]-j</code> 两部分和的最大值。</p>
<p>随着遍历数组，我们对两部分和取最大值，并且若当前的值减下标对之和比之前更大，我们就更新left部分的值即可</p>
<p><strong>Java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxScoreSightseeingPair</span><span class="params">(<span class="type">int</span>[] values)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> values[<span class="number">0</span>], ans = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">            ans = Math.max(ans, tmp + values[i] - i);</span><br><span class="line">            tmp = Math.max(tmp, values[i] + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="309-最佳买卖股票时机含冷冻期"><a href="#309-最佳买卖股票时机含冷冻期" class="headerlink" title="309. 最佳买卖股票时机含冷冻期"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. 最佳买卖股票时机含冷冻期</a></h4><p><code>dp[0][1]</code> 只影响 <code>dp[1][2]</code> ，而 <code>dp[1][2]</code> 又是由 <code>dp[0][1]</code> 和 <code>dp[0][2]</code> 共同决定的，而 <code>dp[0][2]</code> 如上文所说，肯定就是 <code>0</code> 。 因此 <code>dp[1][2] = Math.max(dp[0][1], dp[0][2]);</code> ，只要 <code>dp[0][1] ≤ 0</code> 都是不会造成影响的</p>
<p><strong>Java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp[i][0]: 持有股票</span></span><br><span class="line">        <span class="comment">// dp[i][1]: 不持有股票，本日卖出，下一天为冷冻期</span></span><br><span class="line">        <span class="comment">// dp[i][2]: 不持有股票，本日无卖出，下一天非冷冻期</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len][<span class="number">3</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 持有股票: 1.昨天持有股票 2.本日买入（条件：昨天不持有）</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>] - prices[i]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 本日卖出: (条件:昨天持有)</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不持有，不卖出: 1.昨天卖出，不持有 2.昨天没卖出，但也不持有</span></span><br><span class="line">            dp[i][<span class="number">2</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后一天持有股票不会有收益</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(dp[len - <span class="number">1</span>][<span class="number">1</span>], dp[len - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>空间优化</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp0: 持有股票</span></span><br><span class="line">        <span class="comment">// dp1: 不持有股票，本日卖出，下一天为冷冻期</span></span><br><span class="line">        <span class="comment">// dp2: 不持有股票，本日无卖出，下一天非冷冻期</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">dp0</span> <span class="operator">=</span> -prices[<span class="number">0</span>], dp1 = <span class="number">0</span>, dp2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 持有股票: 1.昨天持有股票 2.本日买入（条件：昨天不持有）</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">d0</span> <span class="operator">=</span> Math.max(dp0, dp2 - prices[i]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 本日卖出: (条件:昨天持有)</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">d1</span> <span class="operator">=</span> dp0 + prices[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不持有，不卖出: 1.昨天卖出，不持有 2.昨天没卖出，但也不持有</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">d2</span> <span class="operator">=</span> Math.max(dp1, dp2);</span><br><span class="line"></span><br><span class="line">            dp0 = d0;</span><br><span class="line">            dp1 = d1;</span><br><span class="line">            dp2 = d2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后一天持有股票不会有收益</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(dp1, dp2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="714-买卖股票的最佳时机含手续费"><a href="#714-买卖股票的最佳时机含手续费" class="headerlink" title="714. 买卖股票的最佳时机含手续费"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714. 买卖股票的最佳时机含手续费</a></h4><ul>
<li><b>sell: </b> 找到最佳卖出价格</li>
<li><b>buy: </b> 找到最佳买入价格</li>
</ul>
<p><strong>Java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices, <span class="type">int</span> fee)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">buy</span> <span class="operator">=</span> -prices[<span class="number">0</span>], sell = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            sell = Math.max(sell, buy + prices[i] - fee);</span><br><span class="line">            buy = Math.max(buy, sell - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>动态规划</tag>
        <tag>Java</tag>
        <tag>python</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇博客</title>
    <url>/2022/03/31/first-blog/</url>
    <content><![CDATA[<p>欢迎来到这！这是测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<img src="/2022/03/31/first-blog/logo.png" class="" title="alt">
<img src="/2022/03/31/first-blog/4.jpg" class="">]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/06/04/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
